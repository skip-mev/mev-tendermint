(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{723:function(e,t,n){"use strict";n.r(t);var o=n(1),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"rfc-002-interprocess-communication-ipc-in-tendermint"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rfc-002-interprocess-communication-ipc-in-tendermint"}},[e._v("#")]),e._v(" RFC 002: Interprocess Communication (IPC) in Tendermint")]),e._v(" "),n("h2",{attrs:{id:"changelog"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#changelog"}},[e._v("#")]),e._v(" Changelog")]),e._v(" "),n("ul",[n("li",[e._v("08-Sep-2021: Initial draft (@creachadair).")])]),e._v(" "),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("Communication in Tendermint among consensus nodes, applications, and operator\ntools all use different message formats and transport mechanisms.  In some\ncases there are multiple options. Having all these options complicates both the\ncode and the developer experience, and hides bugs. To support a more robust,\ntrustworthy, and usable system, we should document which communication paths\nare essential, which could be removed or reduced in scope, and what we can\nimprove for the most important use cases.")]),e._v(" "),n("p",[e._v("This document proposes a variety of possible improvements of varying size and\nscope. Specific design proposals should get their own documentation.")]),e._v(" "),n("h2",{attrs:{id:"background"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),n("p",[e._v("The Tendermint state replication engine has a complex IPC footprint.")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("Consensus nodes communicate with each other using a networked peer-to-peer\nmessage-passing protocol.")])]),e._v(" "),n("li",[n("p",[e._v("Consensus nodes communicate with the application whose state is being\nreplicated via the "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/tree/main/spec/abci",target:"_blank",rel:"noopener noreferrer"}},[e._v("Application BlockChain Interface (ABCI)"),n("OutboundLink")],1),e._v(".")])]),e._v(" "),n("li",[n("p",[e._v("Consensus nodes export a network-accessible "),n("a",{attrs:{href:"https://docs.tendermint.com/v0.34/rpc/",target:"_blank",rel:"noopener noreferrer"}},[e._v("RPC service"),n("OutboundLink")],1),e._v(" to\nsupport operations (bootstrapping, debugging) and synchronization of "),n("a",{attrs:{href:"https://docs.tendermint.com/v0.34/tendermint-core/light-client.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("light clients"),n("OutboundLink")],1),e._v(".\nThis interface is also used by the "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/tree/main/cmd/tendermint",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("tendermint")]),e._v(" CLI"),n("OutboundLink")],1),e._v(".")])]),e._v(" "),n("li",[n("p",[e._v("Consensus nodes export a gRPC service exposing a subset of the methods of\nthe RPC service described by (3). This was intended to simplify the\nimplementation of tools that already use gRPC to communicate with an\napplication (via the Cosmos SDK), and wanted to also talk to the consensus\nnode without implementing yet another RPC protocol.")]),e._v(" "),n("p",[e._v("The gRPC interface to the consensus node has been deprecated and is slated\nfor removal in the forthcoming Tendermint v0.36 release.")])]),e._v(" "),n("li",[n("p",[e._v('Consensus nodes may optionally communicate with a "remote signer" that holds\na validator key and can provide public keys and signatures to the consensus\nnode. One of the stated goals of this configuration is to allow the signer\nto be run on a private network, separate from the consensus node, so that a\ncompromise of the consensus node from the public network would be less\nlikely to expose validator keys.')])])]),e._v(" "),n("h2",{attrs:{id:"discussion-transport-mechanisms"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#discussion-transport-mechanisms"}},[e._v("#")]),e._v(" Discussion: Transport Mechanisms")]),e._v(" "),n("h3",{attrs:{id:"remote-signer-transport"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remote-signer-transport"}},[e._v("#")]),e._v(" Remote Signer Transport")]),e._v(" "),n("p",[e._v("A remote signer communicates with the consensus node in one of two ways:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v('"Raw": Using a TCP or Unix-domain socket which carries varint-prefixed\nprotocol buffer messages. In this mode, the consensus node is the server,\nand the remote signer is the client.')]),e._v(" "),n("p",[e._v("This mode has been deprecated, and is intended to be removed.")])]),e._v(" "),n("li",[n("p",[e._v('gRPC: This mode uses the same protobuf messages as "Raw" node, but uses a\nstandard encrypted gRPC HTTP/2 stub as the transport. In this mode, the\nremote signer is the server and the consensus node is the client.')])])]),e._v(" "),n("h3",{attrs:{id:"abci-transport"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abci-transport"}},[e._v("#")]),e._v(" ABCI Transport")]),e._v(" "),n("p",[e._v("In ABCI, the "),n("em",[e._v("application")]),e._v(" is the server, and the Tendermint consensus engine\nis the client.  Most applications implement the server using the "),n("a",{attrs:{href:"https://github.com/cosmos/cosmos-sdk/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cosmos SDK"),n("OutboundLink")],1),e._v(",\nwhich handles low-level details of the ABCI interaction and provides a\nhigher-level interface to the rest of the application. The SDK is written in Go.")]),e._v(" "),n("p",[e._v("Beneath the SDK, the application communicates with Tendermint core in one of\ntwo ways:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("In-process direct calls (for applications written in Go and compiled against\nthe Tendermint code).  This is an optimization for the common case where an\napplication is written in Go, to save on the overhead of marshaling and\nunmarshaling requests and responses within the same process:\n"),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/main/abci/client/local_client.go",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("abci/client/local_client.go")]),n("OutboundLink")],1)])]),e._v(" "),n("li",[n("p",[e._v('A custom remote procedure protocol built on wire-format protobuf messages\nusing a socket (the "socket protocol"): '),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/main/abci/server/socket_server.go",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("abci/server/socket_server.go")]),n("OutboundLink")],1)])])]),e._v(" "),n("p",[e._v("The SDK also provides a "),n("a",{attrs:{href:"https://pkg.go.dev/github.com/cosmos/cosmos-sdk/types/tx#ServiceServer",target:"_blank",rel:"noopener noreferrer"}},[e._v("gRPC service"),n("OutboundLink")],1),e._v(" accessible from outside the\napplication, allowing transactions to be broadcast to the network, look up\ntransactions, and simulate transaction costs.")]),e._v(" "),n("h3",{attrs:{id:"rpc-transport"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rpc-transport"}},[e._v("#")]),e._v(" RPC Transport")]),e._v(" "),n("p",[e._v('The consensus node RPC service allows callers to query consensus parameters\n(genesis data, transactions, commits), node status (network info, health\nchecks), application state (abci_query, abci_info), mempool state, and other\nattributes of the node and its application. The service also provides methods\nallowing transactions and evidence to be injected ("broadcast") into the\nblockchain.')]),e._v(" "),n("p",[e._v("The RPC service is exposed in several ways:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("HTTP GET: Queries may be sent as URI parameters, with method names in the path.")])]),e._v(" "),n("li",[n("p",[e._v("HTTP POST: Queries may be sent as JSON-RPC request messages in the body of an\nHTTP POST request.  The server uses a custom implementation of JSON-RPC that\nis not fully compatible with the "),n("a",{attrs:{href:"https://www.jsonrpc.org/specification",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSON-RPC 2.0 spec"),n("OutboundLink")],1),e._v(", but handles\nthe common cases.")])]),e._v(" "),n("li",[n("p",[e._v("Websocket: Queries may be sent as JSON-RPC request messages via a websocket.\nThis transport uses more or less the same JSON-RPC plumbing as the HTTP POST\nhandler.")]),e._v(" "),n("p",[e._v("The websocket endpoint also includes three methods that are "),n("em",[e._v("only")]),e._v(" exported\nvia websocket, which appear to support event subscription.")])]),e._v(" "),n("li",[n("p",[e._v("gRPC: A subset of queries may be issued in protocol buffer format to the gRPC\ninterface described above under (4). As noted, this endpoint is deprecated\nand will be removed in v0.36.")])])]),e._v(" "),n("h3",{attrs:{id:"opportunities-for-simplification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#opportunities-for-simplification"}},[e._v("#")]),e._v(" Opportunities for Simplification")]),e._v(" "),n("p",[n("strong",[e._v("Claim:")]),e._v(" There are too many IPC mechanisms.")]),e._v(" "),n("p",[e._v("The preponderance of ABCI usage is via the Cosmos SDK, which means the\napplication and the consensus node are compiled together into a single binary,\nand the consensus node calls the ABCI methods of the application directly as Go\nfunctions.")]),e._v(" "),n("p",[e._v("We also need a true IPC transport to support ABCI applications "),n("em",[e._v("not")]),e._v(" written in\nGo.  There are also several known applications written in Rust, for example\n(including "),n("a",{attrs:{href:"https://github.com/anoma/anoma",target:"_blank",rel:"noopener noreferrer"}},[e._v("Anoma"),n("OutboundLink")],1),e._v(", Penumbra,\n"),n("a",{attrs:{href:"https://github.com/oasisprotocol/oasis-core",target:"_blank",rel:"noopener noreferrer"}},[e._v("Oasis"),n("OutboundLink")],1),e._v(", Twilight, and\n"),n("a",{attrs:{href:"https://github.com/nomic-io/nomic",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nomic"),n("OutboundLink")],1),e._v('). Ideally we will have at most one\nsuch transport "built-in": More esoteric cases can be handled by a custom proxy.\nPragmatically, gRPC is probably the right choice here.')]),e._v(" "),n("p",[e._v('The primary consumers of the multi-headed "RPC service" today are the light\nclient and the '),n("code",[e._v("tendermint")]),e._v(" command-line client. There is probably some local\nuse via curl, but I expect that is mostly ad hoc. Ethan reports that nodes are\noften configured with the ports to the RPC service blocked, which is good for\nsecurity but complicates use by the light client.")]),e._v(" "),n("h3",{attrs:{id:"context-remote-signer-issues"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-remote-signer-issues"}},[e._v("#")]),e._v(" Context: Remote Signer Issues")]),e._v(" "),n("p",[e._v('Since the remote signer needs a secure communication channel to exchange keys\nand signatures, and is expected to run truly remotely from the node (i.e., on a\nseparate physical server), there is not a whole lot we can do here. We should\nfinish the deprecation and removal of the "raw" socket protocol between the\nconsensus node and remote signers, but the use of gRPC is appropriate.')]),e._v(" "),n("p",[e._v('The main improvement we can make is to simplify the implementation quite a bit,\nonce we no longer need to support both "raw" and gRPC transports.')]),e._v(" "),n("h3",{attrs:{id:"context-abci-issues"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-abci-issues"}},[e._v("#")]),e._v(" Context: ABCI Issues")]),e._v(" "),n("p",[e._v("In the original design of ABCI, the presumption was that all access to the\napplication should be mediated by the consensus node. The idea is that outside\naccess could change application state and corrupt the consensus process, which\nrelies on the application to be deterministic. Of course, even without outside\naccess an application could behave nondeterministically, but allowing other\nprograms to send it requests was seen as courting trouble.")]),e._v(" "),n("p",[e._v('Conversely, users noted that most of the time, tools written for a particular\napplication don\'t want to talk to the consensus module directly. The\napplication "owns" the state machine the consensus engine is replicating, so\ntools that care about application state should talk to the application.\nOtherwise, they would have to bake in knowledge about Tendermint (e.g., its\ninterfaces and data structures) just because of the mediation.')]),e._v(" "),n("p",[e._v("For clients to talk directly to the application, however, there is another\nconcern: The consensus node is the ABCI "),n("em",[e._v("client")]),e._v(', so it is inconvenient for the\napplication to "push" work into the consensus module via ABCI itself.  The\ncurrent implementation works around this by calling the consensus node\'s RPC\nservice, which exposes an '),n("code",[e._v("ABCIQuery")]),e._v(" kitchen-sink method that allows the\napplication a way to poke ABCI messages in the other direction.")]),e._v(" "),n("p",[e._v('Without this RPC method, you could work around this (at least in principle) by\nhaving the consensus module "poll" the application for work that needs done,\nbut that has unsatisfactory implications for performance and robustness, as\nwell as being harder to understand.')]),e._v(" "),n("p",[e._v("There has apparently been discussion about trying to make a more bidirectional\ncommunication between the consensus node and the application, but this issue\nseems to still be unresolved.")]),e._v(" "),n("p",[e._v("Another complication of ABCI is that it requires the application (server) to\nmaintain "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/main/spec/abci/apps.md#state",target:"_blank",rel:"noopener noreferrer"}},[e._v("four separate connections"),n("OutboundLink")],1),e._v(': One for "consensus" operations\n(BeginBlock, EndBlock, DeliverTx, Commit), one for "mempool" operations, one\nfor "query" operations, and one for "snapshot" (state synchronization) operations.\nThe rationale seems to have been that these groups of operations should be able\nto proceed concurrently with each other. In practice, it results in a very complex\nstate management problem to coordinate state updates between the separate streams.\nWhile application authors in Go are mostly insulated from that complexity by the\nCosmos SDK, the plumbing to maintain those separate streams is complicated, hard\nto understand, and we suspect it contains concurrency bugs and/or lock contention\nissues affecting performance that are subtle and difficult to pin down.')]),e._v(" "),n("p",[e._v("Even without changing the semantics of any ABCI operations, this code could be\nmade smaller and easier to debug by separating the management of concurrency\nand locking from the IPC transport: If all requests and responses are routed\nthrough one connection, the server can explicitly maintain priority queues for\nrequests and responses, and make less-conservative decisions about when locks\nare (or aren't) required to synchronize state access. With independent queues,\nthe server must lock conservatively, and no optimistic scheduling is practical.")]),e._v(" "),n("p",[e._v("This would be a tedious implementation change, but should be achievable without\nbreaking any of the existing interfaces. More importantly, it could potentially\naddress a lot of difficult concurrency and performance problems we currently\nsee anecdotally but have difficultly isolating because of how intertwined these\nseparate message streams are at runtime.")]),e._v(" "),n("p",[e._v("TODO: Impact of ABCI++ for this topic?")]),e._v(" "),n("h3",{attrs:{id:"context-rpc-issues"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#context-rpc-issues"}},[e._v("#")]),e._v(" Context: RPC Issues")]),e._v(" "),n("p",[e._v("The RPC system serves several masters, and has a complex surface area. I\nbelieve there are some improvements that can be exposed by separating some of\nthese concerns.")]),e._v(" "),n("p",[e._v("The Tendermint light client currently uses the RPC service to look up blocks\nand transactions, and to forward ABCI queries to the application.  The light\nclient proxy uses the RPC service via a websocket. The Cosmos IBC relayer also\nuses the RPC service via websocket to watch for transaction events, and uses\nthe "),n("code",[e._v("ABCIQuery")]),e._v(" method to fetch information and proofs for posted transactions.")]),e._v(" "),n("p",[e._v("Some work is already underway toward using P2P message passing rather than RPC\nto synchronize light client state with the rest of the network.  IBC relaying,\nhowever, requires access to the event system, which is currently not accessible\nexcept via the RPC interface. Event subscription "),n("em",[e._v("could")]),e._v(" be exposed via P2P,\nbut that is a larger project since it adds P2P communication load, and might\nthus have an impact on the performance of consensus.")]),e._v(" "),n("p",[e._v("If event subscription can be moved into the P2P network, we could entirely\nremove the websocket transport, even for clients that still need access to the\nRPC service. Until then, we may still be able to reduce the scope of the\nwebsocket endpoint to "),n("em",[e._v("only")]),e._v(" event subscription, by moving uses of the RPC\nserver as a proxy to ABCI over to the gRPC interface.")]),e._v(" "),n("p",[e._v("Having the RPC server still makes sense for local bootstrapping and operations,\nbut can be further simplified. Here are some specific proposals:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Remove the HTTP GET interface entirely.")])]),e._v(" "),n("li",[n("p",[e._v("Simplify JSON-RPC plumbing to remove unnecessary reflection and wrapping.")])]),e._v(" "),n("li",[n("p",[e._v("Remove the gRPC interface (this is already planned for v0.36).")])]),e._v(" "),n("li",[n("p",[e._v("Separate the websocket interface from the rest of the RPC service, and\nrestrict it to only event subscription.")]),e._v(" "),n("p",[e._v("Eventually we should try to emove the websocket interface entirely, but we\nwill need to revisit that (probably in a new RFC) once we've done some of the\neasier things.")])])]),e._v(" "),n("p",[e._v("These changes would preserve the ability of operators to issue queries with\ncurl (but would require using JSON-RPC instead of URI parameters). That would\nbe a little less user-friendly, but for a use case that should not be that\nprevalent.")]),e._v(" "),n("p",[e._v("These changes would also preserve compatibility with existing JSON-RPC based\ncode paths like the "),n("code",[e._v("tendermint")]),e._v(" CLI and the light client (even ahead of\nfurther work to remove that dependency).")]),e._v(" "),n("p",[n("strong",[e._v("Design goal:")]),e._v(" An operator should be able to disable non-local access to the\nRPC server on any node in the network without impairing the ability of the\nnetwork to function for service of state replication, including light clients.")]),e._v(" "),n("p",[n("strong",[e._v("Design principle:")]),e._v(" All communication required to implement and monitor the\nconsensus network should use P2P, including the various synchronizations.")]),e._v(" "),n("h3",{attrs:{id:"options-for-abci-transport"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#options-for-abci-transport"}},[e._v("#")]),e._v(" Options for ABCI Transport")]),e._v(" "),n("p",[e._v('The majority of current usage is in Go, and the majority of that is mediated by\nthe Cosmos SDK, which uses the "direct call" interface. There is probably some\nopportunity to clean up the implementation of that code, notably by inverting\nwhich interface is at the "top" of the abstraction stack (currently it acts\nlike an RPC interface, and escape-hatches into the direct call). However, this\ngeneral approach works fine and doesn\'t need to be fundamentally changed.')]),e._v(" "),n("p",[e._v("For applications "),n("em",[e._v("not")]),e._v(' written in Go, the two remaining options are the\n"socket" protocol (another variation on varint-prefixed protobuf messages over\nan unstructured stream) and gRPC. It would be nice if we could get rid of one\nof these to reduce (unneeded?) optionality.')]),e._v(" "),n("p",[e._v('Since both the socket protocol and gRPC depend on protocol buffers, the\n"socket" protocol is the most obvious choice to remove. While gRPC is more\ncomplex, the set of languages that '),n("em",[e._v("have")]),e._v(" protobuf support but "),n("em",[e._v("lack")]),e._v(" gRPC\nsupport is small. Moreover, gRPC is already widely used in the rest of the\necosystem (including the Cosmos SDK).")]),e._v(" "),n("p",[e._v("If some use case did arise later that can't work with gRPC, it would not be too\ndifficult for that application author to write a little proxy (in Go) that\nbridges the convenient SDK APIs into a simpler protocol than gRPC.")]),e._v(" "),n("p",[n("strong",[e._v("Design principle:")]),e._v(" It is better for an uncommon special case to carry the\nburdens of its specialness, than to bake an escape hatch into the infrastructure.")]),e._v(" "),n("p",[n("strong",[e._v("Recommendation:")]),e._v(" We should deprecate and remove the socket protocol.")]),e._v(" "),n("h3",{attrs:{id:"options-for-rpc-transport"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#options-for-rpc-transport"}},[e._v("#")]),e._v(" Options for RPC Transport")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/main/docs/architecture/adr-057-RPC.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("ADR 057"),n("OutboundLink")],1),e._v(" proposes using gRPC for the Tendermint RPC implementation.\nThis is still possible, but if we are able to simplify and decouple the\nconcerns as described above, I do not think it should be necessary.")]),e._v(" "),n("p",[e._v("While JSON-RPC is not the best possible RPC protocol for all situations, it has\nsome advantages over gRPC for our domain. Specifically:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("It is easy to call JSON-RPC manually from the command-line, which helps with\na common concern for the RPC service, local debugging and operations.")]),e._v(" "),n("p",[e._v("Relatedly: JSON is relatively easy for humans to read and write, and it can\nbe easily copied and pasted to share sample queries and debugging results in\nchat, issue comments, and so on. Ideally, the RPC service will not be used\nfor activities where the costs of a text protocol are important compared to\nits legibility and manual usability benefits.")])]),e._v(" "),n("li",[n("p",[e._v("gRPC has an enormous dependency footprint for both clients and servers, and\nmany of the features it provides to support security and performance\n(encryption, compression, streaming, etc.) are mostly irrelevant to local\nuse. Tendermint already needs to include a gRPC client for the remote signer,\nbut if we can avoid the need for a "),n("em",[e._v("client")]),e._v(" to depend on gRPC, that is a win\nfor usability.")])]),e._v(" "),n("li",[n("p",[e._v("If we intend to migrate light clients off RPC to use P2P entirely, there is\nno advantage to forcing a temporary migration to gRPC along the way; and once\nthe light client is not dependent on the RPC service, the efficiency of the\nprotocol is much less important.")])]),e._v(" "),n("li",[n("p",[e._v("We can still get the benefits of generated data types using protocol buffers, even\nwithout using gRPC:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Protobuf defines a standard JSON encoding for all message types so\nlanguages with protobuf support do not need to worry about type mapping\noddities.")])]),e._v(" "),n("li",[n("p",[e._v("Using JSON means that even languages "),n("em",[e._v("without")]),e._v(" good protobuf support can\nimplement the protocol with a bit more work, and I expect this situation to\nbe rare.")])])])])]),e._v(" "),n("p",[e._v("Even if a language lacks a good standard JSON-RPC mechanism, the protocol is\nlightweight and can be implemented by simple send/receive over TCP or\nUnix-domain sockets with no need for code generation, encryption, etc. gRPC\nuses a complex HTTP/2 based transport that is not easily replicated.")]),e._v(" "),n("h3",{attrs:{id:"future-work"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#future-work"}},[e._v("#")]),e._v(" Future Work")]),e._v(" "),n("p",[e._v("The background and proposals sketched above focus on the existing structure of\nTendermint and improvements we can make in the short term. It is worthwhile to\nalso consider options for longer-term broader changes to the IPC ecosystem.\nThe following outlines some ideas at a high level:")]),e._v(" "),n("ul",[n("li",[n("p",[n("strong",[e._v("Consensus service:")]),e._v(" Today, the application and the consensus node are\nnominally connected only via ABCI. Tendermint was originally designed with\nthe assumption that all communication with the application should be mediated\nby the consensus node.  Based on further experience, however, the design goal\nis now that the "),n("em",[e._v("application")]),e._v(" should be the mediator of application state.")]),e._v(" "),n("p",[e._v("As noted above, however, ABCI is a client/server protocol, with the\napplication as the server. For outside clients that turns out to have been a\ngood choice, but it complicates the relationship between the application and\nthe consensus node: Previously transactions were entered via the node, now\nthey are entered via the app.")]),e._v(" "),n("p",[e._v('We have worked around this by using the Tendermint RPC service to give the\napplication a "back channel" to the consensus node, so that it can push\ntransactions back into the consensus network. But the RPC service exposes a\nlot of other functionality, too, including event subscription, block and\ntransaction queries, and a lot of node status information.')]),e._v(" "),n("p",[e._v('Even if we can\'t easily "fix" the orientation of the ABCI relationship, we\ncould improve isolation by splitting out the parts of the RPC service that\nthe application needs as a back-channel, and sharing those '),n("em",[e._v("only")]),e._v(' with the\napplication. By defining a "consensus service", we could give the application\na way to talk back limited to only the capabilities it needs. This approach\nhas the benefit that we could do it without breaking existing use, and if we\nlater did "fix" the ABCI directionality, we could drop the special case\nwithout disrupting the rest of the RPC interface.')])]),e._v(" "),n("li",[n("p",[n("strong",[e._v("Event service:")]),e._v(" Right now, the IBC relayer relies on the Tendermint RPC\nservice to provide a stream of block and transaction events, which it uses to\ndiscover which transactions need relaying to other chains.  While I think\nthat event subscription should eventually be handled via P2P, we could gain\nsome immediate benefit by splitting out event subscription from the rest of\nthe RPC service.")]),e._v(" "),n("p",[e._v("In this model, an event subscription service would be exposed on the public\nnetwork, but on a different endpoint. This would remove the need for the RPC\nservice to support the websocket protocol, and would allow operators to\nisolate potentially sensitive status query results from the public network.")]),e._v(" "),n("p",[e._v("At the moment the relayers also use the RPC service to get block data for\nsynchronization, but work is already in progress to handle that concern via\nthe P2P layer. Once that's done, event subscription could be separated.")])])]),e._v(" "),n("p",[e._v("Separating parts of the existing RPC service is not without cost: It might\nrequire additional connection endpoints, for example, though it is also not too\ndifficult for multiple otherwise-independent services to share a connection.")]),e._v(" "),n("p",[e._v("In return, though, it would become easier to reduce transport options and for\noperators to independently control access to sensitive data. Considering the\nviability and implications of these ideas is beyond the scope of this RFC, but\nthey are documented here since they follow from the background we have already\ndiscussed.")]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")])])}),[],!1,null,null,null);t.default=s.exports}}]);